# Week 2: Multi-User App with Tags

**Time Estimate**: 4-5 hours  
**Goal**: Add user accounts and intelligent tagging

Welcome back! In Week 1, you built a working "Ingredient Knowledge Base." It was great, but it had one major flaw: everyone who visited the site saw the same data. If you added "Shea Butter," I would see it too. In the real world, we want our own private accounts.

This week, we are going to transform your app into a **Multi-User Application**. We'll also add a powerful **Tagging System** so you can categorize your ingredients by their benefits (like "Hair Growth" or "Moisturizing").

---

## Part 1: Authentication

### Authentication vs. Authorization: What's the difference?

Before we write code, let's get our definitions straight. These two words sound similar but mean very different things:

1.  **Authentication**: "Who are you?" (The process of proving your identity, usually with an email and password).
2.  **Authorization**: "What are you allowed to do?" (The process of checking if you have permission to see or change a specific piece of data).

In this part, we'll handle both. We'll let users sign up (Authentication) and then make sure they can only see their own ingredients (Authorization).

### Step 1: Generate Rails 8 Authentication

Rails 8 introduced a brand new, built-in way to add authentication. It's simpler than the "old way" (using a gem called Devise) because it generates the code directly into your app so you can see exactly how it works.

**Why not use Devise?**
Devise is a powerful tool, but it's like a "black box"—a lot of the logic is hidden inside the gem. For students, it's much better to see the actual code for `User` and `Session` models so you understand how they work. Rails 8 gives us the best of both worlds: a quick generator that provides clean, readable code.

**What is Authentication?**
Think of it as the "Passport Control" of your application. It's the system that verifies that a person is who they say they are. Without it, anyone could pretend to be you and delete your hard-earned recipes!

**What is Authorization?**
If Authentication is the passport control, Authorization is the "Security Clearance." It's the system that decides what you're allowed to do once you're inside. For example, you're authorized to see *your* ingredients, but not *my* ingredients.

Run this command in your terminal:

```bash
rails generate authentication
```

**What just happened?** Rails created several files for you:
- `app/models/user.rb`: The model that stores email and password. It uses a feature called `has_secure_password` which automatically encrypts your passwords so even if someone stole your database, they couldn't see the actual passwords. This is a vital security practice called "hashing."
- `app/models/session.rb`: Tracks when a user is "logged in." Every time you log in, a new Session record is created. This is how the server knows you're still there.
- `app/controllers/sessions_controller.rb`: Handles the login and logout logic. It's responsible for creating and destroying those Session records.
- `app/controllers/registrations_controller.rb`: Handles signing up new users. It creates the initial User record in the database.
- `app/models/current.rb`: A special file that makes it easy to access the `current_user` anywhere in your app. It's like a global variable that always knows who is currently using the app.

Now, let's update our database to include these new tables:

```bash
rails db:migrate
```

### Step 1b: Create the Sign-Up Flow

**Important:** The Rails 8 authentication generator creates login/logout functionality, but **does not** create user registration (sign-up) functionality. You need to build this yourself.

We'll create only the files we need - just a controller with two actions and one view. This approach teaches you exactly how everything works without generating unnecessary code.

**Step 1: Generate the Controller**

```bash
rails generate controller Users new create --skip-assets --skip-helper
```

This creates a controller with just `new` and `create` actions, without extra helper files.

#### 2. Set Up the Routes

Open `config/routes.rb` and add routes for user registration:

```ruby
Rails.application.routes.draw do
  # Existing authentication routes (generated by rails generate authentication)
  resource :session
  
  # Add these lines for user registration:
  resources :users, only: [:new, :create]
  
  # Your other routes
  resources :ingredients
  
  root "ingredients#index"
end
```

#### 3. Implement the Users Controller

Open `app/controllers/users_controller.rb` and add the sign-up logic:

```ruby
class UsersController < ApplicationController
  # Allow unauthenticated users to sign up
  allow_unauthenticated_access only: %i[new create]

  def new
    @user = User.new
  end

  def create
    @user = User.new(user_params)

    if @user.save
      # Automatically log in the user after signup
      session = @user.sessions.create!
      cookies.signed[:session_id] = { value: session.id, httponly: true }
      
      redirect_to root_path, notice: "Welcome! Your account has been created."
    else
      render :new, status: :unprocessable_entity
    end
  end

  private

  def user_params
    # Require password confirmation for security
    params.require(:user).permit(:email_address, :password, :password_confirmation)
  end
end
```

**What's happening here?**
- `allow_unauthenticated_access` lets non-logged-in users access the signup page
- `password_confirmation` ensures the user typed their password correctly twice
- After saving the user, we create a session and set a cookie (just like the login process)
- The user is automatically logged in after signing up

#### 4. Verify the Root Route

The controller code uses `redirect_to root_path` after successful signup. This requires a root route to be defined in your `config/routes.rb` file.

**Check your routes file now:**
Open `config/routes.rb` and verify it has this line:

```ruby
root "ingredients#index"
```

**If you don't have this line, add it.** This creates the `root_path` helper that we use to redirect users after they sign up.

**Note:** This assumes you have an Ingredients controller with an index action from Week 1. If you haven't created that yet, you should go back and complete Week 1 first, or change the redirect in the UsersController to `redirect_to ingredients_path` instead.

#### 5. Update the Sign-Up Form

The controller generator already created the view file for us. In VS Code:

1. Look in the Explorer sidebar on the left under `app/views/users`
2. You should see `new.html.erb` already exists (Rails created it automatically)
3. Click on `new.html.erb` to open it
4. **Delete any existing content** and replace it with our sign-up form:

Now add the sign-up form code:

```erb
<div class="max-w-md mx-auto mt-10 p-6 bg-white rounded-lg shadow-md">
  <h1 class="text-2xl font-bold mb-6 text-center">Create Your Account</h1>

  <%= form_with model: @user, url: users_path, class: "space-y-4" do |form| %>
    <% if @user.errors.any? %>
      <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
        <ul class="list-disc list-inside">
          <% @user.errors.full_messages.each do |message| %>
            <li><%= message %></li>
          <% end %>
        </ul>
      </div>
    <% end %>

    <div>
      <%= form.label :email_address, class: "block text-sm font-medium text-gray-700 mb-1" %>
      <%= form.email_field :email_address, class: "w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500", placeholder: "you@example.com", required: true %>
    </div>

    <div>
      <%= form.label :password, class: "block text-sm font-medium text-gray-700 mb-1" %>
      <%= form.password_field :password, class: "w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500", placeholder: "Choose a strong password", required: true %>
    </div>

    <div>
      <%= form.label :password_confirmation, "Confirm Password", class: "block text-sm font-medium text-gray-700 mb-1" %>
      <%= form.password_field :password_confirmation, class: "w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500", placeholder: "Type your password again", required: true %>
    </div>

    <%= form.submit "Create Account", class: "w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 transition duration-200 font-medium" %>
  <% end %>

  <div class="mt-4 text-center text-sm text-gray-600">
    Already have an account? 
    <%= link_to "Log in", new_session_path, class: "text-blue-600 hover:underline" %>
  </div>
</div>
```

**Key features of this form:**
- Shows validation errors if signup fails
- Password confirmation field prevents typos
- Tailwind CSS styling for a professional look
- Link to login page for existing users

#### 6. Update the User Model (Optional but Recommended)

Open `app/models/user.rb` and add password confirmation validation:

```ruby
class User < ApplicationRecord
  has_secure_password
  has_many :sessions, dependent: :destroy
  has_many :ingredients, dependent: :destroy
  
  # Add validations for better error messages
  validates :email_address, presence: true, uniqueness: { case_sensitive: false }
  validates :password, presence: true, length: { minimum: 8 }, confirmation: true
  validates :password_confirmation, presence: true
end
```

**Why password confirmation?**
It forces the user to type their password twice, preventing typos. If `password` and `password_confirmation` don't match, the user won't be created.

**Check your routes:** Run `rails routes` to verify the new routes appear:
- `/users/new` - Signup page
- `/users` (POST) - Create user action
- `/session/new` - Login page
- `/session` - Logout action

### Step 2: Understanding Sessions (The Cookie Analogy)

How does the server remember who you are? The internet is "stateless," which means every time you click a link, the server "forgets" who you are.

Imagine you go to a carnival. 
1. You go to the ticket booth and show your ID (**Login/Authentication**).
2. They give you a **wristband** (**The Session Cookie**).
3. For the rest of the day, you don't show your ID anymore. You just show your wristband to get on rides (**Authorization**).

Rails handles this "wristband" for you automatically using **Sessions**. When you log in, Rails puts a small piece of data (a cookie) in your browser. Your browser sends that cookie back to the server with every single request.

**Wait, what is a Cookie?**
A cookie is just a tiny text file that the server asks your browser to save. It's like a name tag that says "I am User #42." Every time you visit a new page on the same site, your browser automatically shows that name tag to the server. This is how Amazon remembers what's in your cart even if you close the tab!

**Is it safe?**
Yes! Rails encrypts the cookie so that users can't change their ID to someone else's. It's like a wristband that's impossible to take off or fake.

### Step 3: Test Signup and Login

Start your server:
```bash
bin/rails server
```

1. Navigate to `http://localhost:3000/users/new` (the sign-up page we created).
2. Create a new account:
   - Email: `test@example.com`
   - Password: Choose something you'll remember (at least 8 characters)
   - Confirm Password: Must match exactly
3. After clicking "Create Account", you should be automatically logged in and redirected to the home page.
4. Try logging out and logging back in:
   - Click "Logout" in the navigation
   - Navigate to `/session/new` to log back in
   - Use the email and password you just created
5. Notice how the navigation bar changes when you're logged in vs. logged out.

**Pro Tip**: If you get stuck or forget your password, you can reset it from the console:
```bash
rails console
# Then type:
user = User.find_by(email: "test@example.com")
user.update(password: "newpassword123")
```

### Step 3b: Add Navigation Links

You need login/logout links in your navigation bar. Open `app/views/layouts/application.html.erb`.

**Check your main element first:**
Your `<main>` element should have `flex flex-col` classes to ensure proper vertical layout:

```erb
<main class="container mx-auto mt-28 px-5 flex flex-col">
```

If it's missing `flex flex-col`, add it now. This ensures the navigation and page content stack vertically.

**Add the navigation bar:**
Place this code at the top of your `<main>` element, before the `<%= yield %>` line:

```erb
<nav class="mb-8 px-6 py-4 bg-white border-b border-gray-200 shadow-sm">
  <div class="max-w-7xl mx-auto flex items-center justify-between">
    <%# Left side - App name and main nav %>
    <div class="flex items-center gap-8">
      <%= link_to root_path, class: "text-xl font-bold text-gray-900 hover:text-blue-600 transition-colors" do %>
        Ingredient Knowledge Base
      <% end %>
      
      <% if authenticated? %>
        <%= link_to "My Ingredients", ingredients_path, class: "text-gray-600 hover:text-gray-900 transition-colors" %>
      <% end %>
    </div>
    
    <%# Right side - Auth links %>
    <div class="flex items-center gap-4">
      <% if authenticated? %>
        <span class="text-sm text-gray-500">
          <%= Current.user.email_address %>
        </span>
        <%= button_to "Logout", session_path, method: :delete, class: "px-4 py-2 text-sm text-red-600 hover:text-red-700 hover:bg-red-50 rounded-lg transition-colors" %>
      <% else %>
        <%= link_to "Sign Up", new_user_path, class: "px-4 py-2 text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 rounded-lg transition-colors" %>
        <%= link_to "Login", new_session_path, class: "px-4 py-2 text-sm font-medium text-gray-700 hover:text-gray-900 hover:bg-gray-100 rounded-lg transition-colors" %>
      <% end %>
    </div>
  </div>
</nav>
```

**What's happening here?**
- `authenticated?` is a helper method from Rails 8 that returns true if a user is logged in
- `Current.user` gives you access to the currently logged-in user
- The links use Rails path helpers (`new_user_path`, `session_path`, etc.) that match the routes from `rails routes`
- **Modern navbar design** with a white background and subtle shadow
- **App branding** on the left with the app name linking to home
- **Navigation link** to "My Ingredients" when logged in
- **User email** displayed subtly when authenticated
- **Styled buttons** - Sign Up is a primary blue button, Login is secondary gray, Logout is red text
- **Hover effects** on all interactive elements for better UX
- **Responsive container** with `max-w-7xl` that centers content on large screens

### Step 4: Scope Ingredients to Users

Right now, ingredients are still "homeless"—they don't belong to anyone. We need to link them to users.

#### 1. Create the Migration
We need to add a `user_id` column to the `ingredients` table. This is called a **Foreign Key**. It's a column that "points" to the ID of a record in another table (the `users` table).

```bash
rails generate migration AddUserToIngredients user:references
```

**What does `user:references` do?**
It does three things:
1. Adds a `user_id` column to the ingredients table.
2. Adds an "index" to make searching by user_id fast.
3. Adds a "foreign key constraint" which is a database rule that says "you can't have an ingredient that points to a user who doesn't exist."

**Wait, what is an Index?**
Imagine a book with 1,000 pages. If you want to find every mention of "Coconut Oil," you have to read every page. That's slow. An **Index** is like the index at the back of the book. It tells the database exactly which pages (rows) have the data you're looking for, so it doesn't have to scan the whole table.

#### 2. Run the Migration

Now run the migration to update your database:

```bash
rails db:migrate
```

**⚠️ Important: Handling Existing Data**
If you have ingredients from Week 1, the migration might fail because existing ingredients don't have a `user_id`. You have two options:

**Option A: Delete all existing ingredients BEFORE running the migration** (simplest for tutorials):
```bash
rails console
Ingredient.destroy_all
exit
rails db:migrate
```

**Option B: Make the column nullable** (for keeping data):
Edit the generated migration file (in `db/migrate/`) and change:
```ruby
t.references :user, null: false, foreign_key: true
```
to:
```ruby
t.references :user, null: true, foreign_key: true
```
Then run `rails db:migrate`. Later, you can manually assign existing ingredients to a user through the console.

#### 3. Update the Models
Tell Rails about the relationship. This is where we define the "rules" of our data.

In `app/models/user.rb`:
```ruby
class User < ApplicationRecord
  has_secure_password
  has_many :sessions, dependent: :destroy
  
  # Add this line:
  # This says: "A user can have many ingredients. If the user is deleted, delete their ingredients too."
  has_many :ingredients, dependent: :destroy
end
```

In `app/models/ingredient.rb`:
```ruby
class Ingredient < ApplicationRecord
  # Add this line:
  # This says: "Every ingredient MUST belong to a user."
  belongs_to :user
  
  validates :name, presence: true
  validates :category, presence: true
  validates :user, presence: true  # Ensures no orphaned ingredients
end
```

#### 4. Update the Seeds File

Now that the migration has run and the database has the `user_id` column, we can update our seeds to create a default user and link all seeded ingredients to that user.

Open `db/seeds.rb` and update it:

```ruby
# db/seeds.rb

# First, create a default user (or find if it already exists)
user = User.find_or_create_by!(email_address: "demo@example.com") do |u|
  u.password = "password123"
  u.password_confirmation = "password123"
end

puts "Created demo user: #{user.email_address}"

# Create ingredients linked to this user
ingredients = [
  { name: "Coconut Oil", category: "Oil", description: "Great for hair moisture" },
  { name: "Shea Butter", category: "Butter", description: "Rich moisturizer for dry hair" },
  { name: "Aloe Vera Gel", category: "Gel", description: "Soothes scalp and adds shine" },
  { name: "Jojoba Oil", category: "Oil", description: "Mimics natural hair sebum" },
  { name: "Castor Oil", category: "Oil", description: "Promotes hair growth" }
]

ingredients.each do |ingredient_data|
  user.ingredients.find_or_create_by!(name: ingredient_data[:name]) do |i|
    i.category = ingredient_data[:category]
    i.description = ingredient_data[:description]
  end
end

puts "Created #{user.ingredients.count} ingredients for demo user!"
```

**Run the seeds:**
```bash
rails db:seed
```

**Why this matters:**
- `user.ingredients.create` automatically sets the `user_id` field
- `find_or_create_by!` prevents duplicates if you run seeds multiple times
- You now have a demo account ready to use (email: `demo@example.com`, password: `password123`)

**Pro Tip:** You can now log in with `demo@example.com` / `password123` to see your seeded ingredients immediately!

#### 5. Understanding the Authentication Concern

The Rails 8 generator created an `Authentication` concern that gets included in `ApplicationController`. This is where all the authentication magic happens!

Open `app/controllers/concerns/authentication.rb` to see how it works:

```ruby
module Authentication
  extend ActiveSupport::Concern

  included do
    before_action :require_authentication
    helper_method :authenticated?
  end

  class_methods do
    def allow_unauthenticated_access(**options)
      skip_before_action :require_authentication, **options
    end
  end

  private
    def authenticated?
      resume_session
    end

    def require_authentication
      resume_session || request_authentication
    end

    def resume_session
      Current.session ||= find_session_by_cookie
    end

    def find_session_by_cookie
      Session.find_by(id: cookies.signed[:session_id]) if cookies.signed[:session_id]
    end

    def request_authentication
      session[:return_to_after_authenticating] = request.url
      redirect_to new_session_path
    end

    def after_authentication_url
      session.delete(:return_to_after_authenticating) || root_url
    end

    def start_new_session_for(user)
      user.sessions.create!(user_agent: request.user_agent, ip_address: request.remote_ip).tap do |session|
        Current.session = session
        cookies.signed.permanent[:session_id] = { value: session.id, httponly: true }
      end
    end

    def terminate_session
      Current.session&.destroy
      cookies.delete(:session_id)
    end
end
```

**How It Works:**

1. **The `before_action` hook**: Every request first runs `require_authentication`, which checks if there's a valid session cookie

2. **Cookie-based sessions**: When you log in, Rails creates a `Session` record and stores its ID in an encrypted cookie (`cookies.signed[:session_id]`)

3. **Resume session**: On each request, `resume_session` looks up the session from the cookie and sets `Current.session`

4. **The `Current` pattern**: Rails 8 uses a `Current` class to store the current user/session globally during a request

5. **Automatic redirect**: If not authenticated, you're redirected to the login page with a `return_to` parameter so you go back to where you were after logging in

**How to Use It:**

The concern provides these helper methods in your controllers:

- `authenticated?` - Returns true if the user is logged in
- `allow_unauthenticated_access` - Skip authentication for specific actions
- `start_new_session_for(user)` - Log a user in (creates session cookie)
- `terminate_session` - Log out (destroys session)

**Example in your IngredientsController:**

```ruby
class IngredientsController < ApplicationController
  # Allow anyone to view the home page (if you had one)
  # allow_unauthenticated_access only: [:home]
  
  # All other actions require login (default behavior)
end
```

The authentication is already working! When you try to visit `/ingredients` without logging in, you'll be redirected to `/session/new` automatically.

---

## Part 2: Tagging System

### Step 5: Understanding Many-to-Many Relationships

In Week 1, we used a simple `category` field (like "Oil" or "Butter"). But what if an ingredient is both "Moisturizing" and "Anti-inflammatory"? A single text field isn't enough.

We need a **Many-to-Many** relationship:
- One **Ingredient** can have many **Tags**.
- One **Tag** can belong to many **Ingredients**.

To make this work in a database, we need a "bridge" or a **Join Table**.

#### What is a Join Table?
Imagine you have a list of Ingredients and a list of Tags. You can't just put a `tag_id` on the Ingredient table, because an ingredient can have *many* tags. You can't put an `ingredient_id` on the Tag table, because a tag can belong to *many* ingredients.

The solution is a third table that just stores pairs of IDs. This is the **Join Table**. It's like a matchmaker that connects two different groups of people.

#### The Analogy: Students and Classes
- One **Student** has many **Classes**.
- One **Class** has many **Students**.
- How do you know which student is in which class? You look at the **Enrollment** list.

In our app:
- **Ingredient** and **Tag** are the students and classes.
- **IngredientTag** is the enrollment list (the Join Table).

#### Database Diagram (ASCII Art)
```
+----------------+       +-------------------+       +-----------+
|   Ingredient   |       |   IngredientTag   |       |    Tag    |
+----------------+       +-------------------+       +-----------+
| id             |<------| ingredient_id     |       | id        |
| name           |       | tag_id            |------>| name      |
| user_id        |       +-------------------+       +-----------+
+----------------+
```

**Wait, why do we need this?**
Without a join table, you'd have to store tags as a long string (like "Moisturizing, Shine, Growth") in a single column. This makes it impossible to search for "all ingredients that are Moisturizing" without doing a very slow and messy text search. With a join table, the database can find those connections instantly!

### Step 6: Create Tag Model

```bash
rails generate model Tag name:string
```

### Step 7: Create Join Table

We use a migration to create the bridge between Ingredients and Tags.

```bash
rails generate migration CreateIngredientTags ingredient:references tag:references
rails db:migrate
```

**Wait, what are "References" again?**
Just like with `user:references`, this tells Rails to create columns (`ingredient_id` and `tag_id`) that point to the other tables. These are the "glue" that holds our many-to-many relationship together.

### Step 8: Create the IngredientTag Model and Set Up Associations

The migration created the database table, but we still need to create the model file for the join table.

#### 1. Create the Join Table Model

In VS Code:
1. Right-click on the `app/models` folder in the Explorer
2. Select **"New File"** and name it `ingredient_tag.rb`
3. Add the following code:

```ruby
class IngredientTag < ApplicationRecord
  # This is the bridge. It belongs to both sides.
  # It's like a link in a chain connecting an Ingredient to a Tag.
  belongs_to :ingredient
  belongs_to :tag
end
```

**Why we need this:**
The migration creates the database table, but Rails still needs a model file to define the associations and provide the Ruby interface to that table.

#### 2. Update the Other Models

Now we tell Rails how to navigate these tables. This is the "magic" of ActiveRecord.

In `app/models/tag.rb`:
```ruby
class Tag < ApplicationRecord
  # A tag can be on many ingredients, but it has to go through the join table first.
  # dependent: :destroy ensures that if a tag is deleted, the "bridge" records are also cleaned up.
  has_many :ingredient_tags, dependent: :destroy
  has_many :ingredients, through: :ingredient_tags
  
  validates :name, presence: true, uniqueness: true
end
```

In `app/models/ingredient.rb`:
```ruby
class Ingredient < ApplicationRecord
  belongs_to :user
  
  # Add these two lines:
  # This allows us to say @ingredient.tags and get a list of all tags!
  # It's much easier than saying @ingredient.ingredient_tags.map(&:tag).
  has_many :ingredient_tags, dependent: :destroy
  has_many :tags, through: :ingredient_tags
  
  validates :name, presence: true
  validates :category, presence: true
end
```

**Why `has_many :through`?**
It allows you to say `@ingredient.tags` instead of having to go through the join table manually. Rails does the hard work of joining the tables for you. Without this, you would have to write complex SQL queries every time you wanted to see an ingredient's tags. It makes your code cleaner, faster to write, and easier to read.

**What is ActiveRecord?**
ActiveRecord is the part of Rails that talks to the database. Instead of writing SQL (Structured Query Language), you write Ruby code. ActiveRecord translates your Ruby into SQL. It's like having a personal translator who speaks "Database" fluently!

### Step 9: Seed Tags

We want some standard tags ready to use. Open `db/seeds.rb` and add:

```ruby
# db/seeds.rb
Tag.destroy_all # Clean up old tags if they exist

tags = [
  "Hair Growth",
  "Moisturizing",
  "Anti-inflammatory",
  "Scalp Soothing",
  "Shine",
  "Curl Definition",
  "Preservative",
  "Emulsifier",
  "Antioxidant",
  "Humectant",
  "Emollient",
  "Surfactant"
]

tags.each do |tag_name|
  # find_or_create_by! is great because it won't create duplicates if you run the seed twice.
  Tag.find_or_create_by!(name: tag_name)
end

puts "Created #{Tag.count} tags!"
```

Run the seed command:
```bash
rails db:seed
```

**What is Seeding?**
Seeding is the process of populating your database with initial data. It's perfect for things like categories, tags, or even a test user account. It ensures that every developer (and eventually your production server) starts with the same basic information.

**Why use `find_or_create_by!`?**
If you use `Tag.create!`, and you run the seed twice, you'll get duplicate tags. `find_or_create_by!` checks if the tag already exists first. If it does, it does nothing. If it doesn't, it creates it. This makes your seed file "idempotent"—a fancy word that means you can run it 100 times and the result will always be the same.

**What does the `!` do?**
In Ruby on Rails, methods ending in `!` (like `create!` or `save!`) will "explode" (raise an error) if they fail. This is actually good! It's better to have the app stop and tell you exactly what's wrong than to have it fail silently and leave you wondering why your tags aren't showing up.

### Step 10: Add Tags to Form

We need a way for users to pick tags when creating an ingredient. We'll use checkboxes.

#### 1. Update the Controller Params
First, we must tell the controller to allow `tag_ids` to be saved. This is part of Rails' "Strong Parameters" security feature.

**What are Strong Parameters?**
In the old days of Rails, a hacker could send extra data in a form (like `user[is_admin]=true`) and the server would just save it. Strong Parameters force us to explicitly "permit" every single field that we want to allow the user to change. It's a vital security layer that protects your app from "Mass Assignment" vulnerabilities.

In `app/controllers/ingredients_controller.rb`:
```ruby
def ingredient_params
  # Add tag_ids: [] to the permit list
  # The [] means we are expecting an ARRAY of IDs (since you can check multiple boxes).
  # Note: tag_ids: [] must be the LAST parameter in the permit() call
  params.expect(ingredient: [ :name, :category, :description, :notes, tag_ids: [] ])
end
```

#### 2. Update the Form View
Open `app/views/ingredients/_form.html.erb` and add this section before the submit button. We're using Tailwind CSS to make the checkboxes look nice in a grid.

```erb
<div class="mb-4">
  <%= form.label :tag_ids, "Benefits & Properties", class: "block font-bold mb-2" %>
  <div class="grid grid-cols-2 gap-2">
    <%# collection_check_boxes is a powerful Rails helper that generates all the checkboxes for us! %>
    <%# It takes 4 main arguments: 
        1. The field name (:tag_ids)
        2. The collection to loop through (Tag.all)
        3. The value to save (:id)
        4. The text to show the user (:name)
    %>
    <%= form.collection_check_boxes :tag_ids, Tag.all, :id, :name do |cb| %>
      <div class="flex items-center">
        <%= cb.check_box class: "w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500" %>
        <%= cb.label class: "ml-2 text-sm text-gray-700" %>
      </div>
    <% end %>
  </div>
</div>
```

**Wait, how does Rails know which boxes are checked?**
When you submit the form, Rails sends an array of IDs (like `[1, 3, 5]`) to the controller. Because we set up `has_many :tags, through: :ingredient_tags`, Rails is smart enough to see those IDs and automatically create the "bridge" records in the `ingredient_tags` table for us. It's like magic, but it's just good engineering!

#### 3. Display Tags on the Show Page
Open `app/views/ingredients/_ingredient.html.erb` (the partial that displays ingredient details). We'll use little "pills" or "badges" to show the tags. This makes the UI look much more professional than just a comma-separated list.

Find where you display ingredient details in the partial, and add this code:

```erb
<p class="mt-4">
  <strong>Tags:</strong>
  <% if ingredient.tags.any? %>
    <div class="flex flex-wrap gap-2 mt-1">
      <% ingredient.tags.each do |tag| %>
        <span class="inline-block bg-blue-100 text-blue-800 text-xs font-semibold px-2.5 py-0.5 rounded-full border border-blue-400">
          <%= tag.name %>
        </span>
      <% end %>
    </div>
  <% else %>
    <span class="text-gray-500 italic">No tags selected</span>
  <% end %>
</p>
```

**Note:** In the partial, we use `ingredient` (not `@ingredient`) because partials receive a local variable.

**Why use `flex-wrap`?**
If you have 20 tags, you don't want them to go off the side of the screen! `flex-wrap` tells the browser to start a new row when it runs out of space.

---

## Verification & Testing

1. **Auth Check**: Can you access `/ingredients` without logging in? (You shouldn't be able to).
2. **Isolation Check**: If you create an ingredient as "User 1", does it show up for "User 2"? (It shouldn't).
3. **Tag Check**: Create a new ingredient and check 3 tags. Do they show up in the ingredient listing and detail views?
4. **Edit Check**: Edit that ingredient and uncheck one tag. Does it disappear?

## Git Commits

It's good practice to commit your work in logical chunks.

**Commit 1: Authentication**
```bash
git add .
git commit -m "feat(auth): add Rails 8 authentication and user scoping"
```

**Commit 2: Tagging System**
```bash
git add .
git commit -m "feat(tags): add many-to-many tagging system"
```

---

## Troubleshooting Common Issues

### Issue: "Can't access ingredients without login, but navigation links aren't showing"
**Solution:** Check that your navigation code is inside the `<body>` tag and you're using the correct Rails path helpers. Run `rails routes | grep session` and `rails routes | grep user` to verify the routes exist.

### Issue: "Migration failed with 'NOT NULL constraint' error"
**Solution:** You have existing ingredients without a user. Follow Option A or B from Step 4.1 above to handle existing data.

### Issue: "Tags aren't saving when I submit the form"
**Solution:** 
1. Check that `tag_ids: []` is in your strong parameters in the controller
2. Make sure you ran `rails db:seed` to create the tags
3. Verify the join table migration ran successfully: `rails db:migrate:status`

### Issue: "Logout link doesn't work - says route not found"
**Solution:** Make sure you're using `method: :delete` in your logout link:
```erb
<%= link_to "Logout", session_path, method: :delete %>
```
Or try:
```erb
<%= button_to "Logout", session_path, method: :delete %>
```

### Issue: "Ingredient validation failed: User must exist"
**Solution:** Ensure you're logged in before creating ingredients. The `belongs_to :user` validation requires a user to be set. Check your controller uses `current_user.ingredients.build()` not just `Ingredient.new()`.

### Issue: "Sign up page shows 'Template is missing' error"
**Solution:** The controller generator should have created `app/views/users/new.html.erb`. If it didn't, you may have skipped the controller generation step. Re-run:
```bash
rails generate controller Users new create --skip-assets --skip-helper
```
Then check `app/views/users/` folder for `new.html.erb`.

### Issue: "Password confirmation doesn't match" error on signup
**Solution:** Make sure both password fields contain exactly the same text. Also check your User model has:
```ruby
validates :password, confirmation: true
```
And that your controller permits `password_confirmation` in `user_params`.

### Issue: "Route not found" error when clicking Sign Up link
**Solution:** Verify your routes file has:
```ruby
resources :users, only: [:new, :create]
```
Run `rails routes | grep user` to check. The link should use `new_user_path`.

### Issue: "Unpermitted parameter: password_confirmation" in server logs
**Solution:** Add `password_confirmation` to your user_params in UsersController:
```ruby
def user_params
  params.require(:user).permit(:email_address, :password, :password_confirmation)
end
```
